/*
 * Copyright © 2021 Michał 'Griwes' Dominiak
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include "cstddef"

namespace std
{
template<typename _T>
void __implicitly_convert(_T);

template<typename _T, typename _U>
concept __implicitly_convertible = requires(_T __t)
{
    { __implicitly_convert<_U>(__t) };
};

template<typename _T, _T _V>
struct integral_constant
{
    static inline constexpr _T value = _V;
};

template<bool _B>
using bool_constant = integral_constant<bool, _B>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

template<typename _T>
struct is_void;
template<typename _T>
struct is_null_pointer;

#if !(__is_identifier(__is_integral))
template<typename _T>
struct is_integral : bool_constant<__is_integral(_T)>
{
};
#else
#error crappy compiler, yo
#endif

template<typename _T>
struct is_floating_point;

template<typename>
struct is_array : false_type
{
};
template<typename _T>
struct is_array<_T[]> : true_type
{
};
template<typename _T, size_t _N>
struct is_array<_T[_N]> : true_type
{
};

template<typename _T>
struct is_pointer : false_type
{
};

template<typename _T>
struct is_pointer<_T *> : true_type
{
};

template<typename _T>
struct is_lvalue_reference;
template<typename _T>
struct is_rvalue_reference;
template<typename _T>
struct is_member_object_pointer;
template<typename _T>
struct is_member_function_pointer;
template<typename _T>
struct is_enum;
template<typename _T>
struct is_union;
template<typename _T>
struct is_class;
template<typename _T>
struct is_function;

template<typename _T>
struct is_reference;
template<typename _T>
struct is_arithmetic;
template<typename _T>
struct is_fundamental;
template<typename _T>
struct is_object;
template<typename _T>
struct is_scalar;
template<typename _T>
struct is_compound;
template<typename _T>
struct is_member_pointer;

template<typename _T>
struct is_const;
template<typename _T>
struct is_volatile;
template<typename _T>
struct is_trivial;
template<typename _T>
struct is_trivially_copyable;
template<typename _T>
struct is_standard_layout;
template<typename _T>
struct is_empty;
template<typename _T>
struct is_polymorphic;
template<typename _T>
struct is_abstract;
template<typename _T>
struct is_final;
template<typename _T>
struct is_aggregate;

template<typename _T>
struct is_signed;
template<typename _T>
struct is_unsigned;

template<typename>
struct is_bounded_array : false_type
{
};
template<typename _T, size_t _N>
struct is_bounded_array<_T[_N]> : true_type
{
};

template<typename>
struct is_unbounded_array : false_type
{
};
template<typename _T>
struct is_unbounded_array<_T[]> : true_type
{
};

template<typename _T>
struct is_scoped_enum;

template<typename _T, typename... _Args>
struct is_constructible;
template<typename _T>
struct is_default_constructible;
template<typename _T>
struct is_copy_constructible;

template<typename _T>
    struct is_move_constructible : bool_constant < requires(_T __t)
{
    { _T(move(__t)) };
} > {};

template<typename _T, typename _U>
struct is_assignable;
template<typename _T>
struct is_copy_assignable;
template<typename _T>
struct is_move_assignable;

template<typename _T, typename _U>
struct is_swappable_with;
template<typename _T>
struct is_swappable;

template<typename _T>
struct is_destructible;

template<typename _T, typename... _Args>
struct is_trivially_constructible;
template<typename _T>
struct is_trivially_default_constructible;
template<typename _T>
struct is_trivially_copy_constructible;
template<typename _T>
struct is_trivially_move_constructible;

template<typename _T, typename _U>
struct is_trivially_assignable;
template<typename _T>
struct is_trivially_copy_assignable;
template<typename _T>
struct is_trivially_move_assignable;
template<typename _T>
struct is_trivially_destructible;

template<typename _T, typename... _Args>
struct is_nothrow_constructible;
template<typename _T>
struct is_nothrow_default_constructible;
template<typename _T>
struct is_nothrow_copy_constructible;
template<typename _T>
struct is_nothrow_move_constructible;

template<typename _T, typename _U>
struct is_nothrow_assignable;
template<typename _T>
struct is_nothrow_copy_assignable;
template<typename _T>
struct is_nothrow_move_assignable;

template<typename _T, typename _U>
struct is_nothrow_swappable_with;
template<typename _T>
struct is_nothrow_swappable;

template<typename _T>
struct is_nothrow_destructible;

template<typename _T>
struct has_virtual_destructor;

template<typename _T>
struct has_unique_object_representations;

template<typename _T>
struct alignment_of;
template<typename _T>
struct rank;
template<typename _T, unsigned _I = 0>
struct extent;

template<typename _T, typename _U>
struct is_same : false_type
{
};

template<typename _T>
struct is_same<_T, _T> : true_type
{
};

template<typename _Base, typename _Derived>
struct is_base_of;
template<typename _From, typename _To>
struct is_convertible;
template<typename _From, typename _To>
struct is_nothrow_convertible;
template<typename _T, typename _U>
struct is_layout_compatible;
template<typename _Base, typename _Derived>
struct is_pointer_interconvertible_base_of;

template<typename _Fn, typename... _ArgTypes>
struct is_invocable;
template<typename _R, typename _Fn, typename... _ArgTypes>
struct is_invocable_r;

template<typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable;
template<typename _R, typename _Fn, typename... _ArgTypes>
struct is_nothrow_invocable_r;

template<typename _T>
struct remove_const;
template<typename _T>
struct remove_volatile;
template<typename _T>
struct remove_cv;
template<typename _T>
struct add_const;
template<typename _T>
struct add_volatile;
template<typename _T>
struct add_cv;

template<typename _T>
using remove_const_t = typename remove_const<_T>::type;
template<typename _T>
using remove_volatile_t = typename remove_volatile<_T>::type;
template<typename _T>
using remove_cv_t = typename remove_cv<_T>::type;
template<typename _T>
using add_const_t = typename add_const<_T>::type;
template<typename _T>
using add_volatile_t = typename add_volatile<_T>::type;
template<typename _T>
using add_cv_t = typename add_cv<_T>::type;

template<typename _T>
struct remove_reference
{
    using type = _T;
};

template<typename _T>
struct remove_reference<_T &>
{
    using type = _T;
};

template<typename _T>
struct remove_reference<_T &&>
{
    using type = _T;
};

template<typename _T>
struct add_lvalue_reference;
template<typename _T>
struct add_rvalue_reference;

template<typename _T>
using remove_reference_t = typename remove_reference<_T>::type;
template<typename _T>
using add_lvalue_reference_t = typename add_lvalue_reference<_T>::type;
template<typename _T>
using add_rvalue_reference_t = typename add_rvalue_reference<_T>::type;

template<typename _T>
struct make_signed;
template<typename _T>
struct make_unsigned;

template<typename _T>
using make_signed_t = typename make_signed<_T>::type;
template<typename _T>
using make_unsigned_t = typename make_unsigned<_T>::type;

template<typename _T>
struct remove_extent
{
    using type = _T;
};
template<typename _T>
struct remove_extent<_T[]>
{
    using type = _T;
};
template<typename _T, size_t _N>
struct remove_extent<_T[_N]>
{
    using type = _T;
};

template<typename _T>
struct remove_all_extents
{
    using type = _T;
};
template<typename _T>
struct remove_all_extents<_T[]>
{
    using type = typename remove_all_extents<_T>::type;
};
template<typename _T, size_t _N>
struct remove_all_extents<_T[_N]>
{
    using type = typename remove_all_extents<_T>::type;
};

template<typename _T>
using remove_extent_t = typename remove_extent<_T>::type;
template<typename _T>
using remove_all_extents_t = typename remove_all_extents<_T>::type;

template<typename _T>
struct remove_pointer;
template<typename _T>
struct add_pointer;

template<typename _T>
using remove_pointer_t = typename remove_pointer<_T>::type;
template<typename _T>
using add_pointer_t = typename add_pointer<_T>::type;

template<typename _T>
struct type_identity;
template<size_t _Len, size_t _Align = 16> // see [meta.trans.other]
struct aligned_storage;
template<size_t _Len, typename... _Types>
struct aligned_union;
template<typename _T>
struct remove_cvref;
template<typename _T>
struct decay;

template<bool _B, typename _T = void>
struct enable_if
{
    using type = _T;
};

template<typename _T>
struct enable_if<false, _T>
{
};

template<bool, typename _T, typename _F>
struct conditional;
template<typename... _T>
struct common_type;
template<typename _T, typename _U, template<typename> typename _TQual, template<typename> typename _UQual>
struct basic_common_reference
{
};
template<typename... _T>
struct common_reference;
template<typename _T>
struct underlying_type;
template<typename _Fn, typename... _ArgTypes>
struct invoke_result;
template<typename _T>
struct unwrap_reference;
template<typename _T>
struct unwrap_ref_decay;

template<typename _T>
using type_identity_t = typename type_identity<_T>::type;
template<size_t _Len, size_t _Align = 16> // see [meta.trans.other]
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
template<size_t _Len, typename... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
template<typename _T>
using remove_cvref_t = typename remove_cvref<_T>::type;
template<typename _T>
using decay_t = typename decay<_T>::type;
template<bool _B, typename _T = void>
using enable_if_t = typename enable_if<_B, _T>::type;
template<bool _B, typename _T, typename _F>
using conditional_t = typename conditional<_B, _T, _F>::type;
template<typename... _T>
using common_type_t = typename common_type<_T...>::type;
template<typename... _T>
using common_reference_t = typename common_reference<_T...>::type;
template<typename _T>
using underlying_type_t = typename underlying_type<_T>::type;
template<typename _Fn, typename... _ArgTypes>
using invoke_result_t = typename invoke_result<_Fn, _ArgTypes...>::type;
template<typename _T>
using unwrap_reference_t = typename unwrap_reference<_T>::type;
template<typename _T>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_T>::type;
template<typename...>
using void_t = void;

template<typename... _B>
struct conjunction;
template<typename... _B>
struct disjunction;
template<typename _B>
struct negation;

template<typename _T>
inline constexpr bool is_void_v = is_void<_T>::value;
template<typename _T>
inline constexpr bool is_null_pointer_v = is_null_pointer<_T>::value;
template<typename _T>
inline constexpr bool is_integral_v = is_integral<_T>::value;
template<typename _T>
inline constexpr bool is_floating_point_v = is_floating_point<_T>::value;
template<typename _T>
inline constexpr bool is_array_v = is_array<_T>::value;
template<typename _T>
inline constexpr bool is_pointer_v = is_pointer<_T>::value;
template<typename _T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<_T>::value;
template<typename _T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<_T>::value;
template<typename _T>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<_T>::value;
template<typename _T>
inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<_T>::value;
template<typename _T>
inline constexpr bool is_enum_v = is_enum<_T>::value;
template<typename _T>
inline constexpr bool is_union_v = is_union<_T>::value;
template<typename _T>
inline constexpr bool is_class_v = is_class<_T>::value;
template<typename _T>
inline constexpr bool is_function_v = is_function<_T>::value;

template<typename _T>
inline constexpr bool is_reference_v = is_reference<_T>::value;
template<typename _T>
inline constexpr bool is_arithmetic_v = is_arithmetic<_T>::value;
template<typename _T>
inline constexpr bool is_fundamental_v = is_fundamental<_T>::value;
template<typename _T>
inline constexpr bool is_object_v = is_object<_T>::value;
template<typename _T>
inline constexpr bool is_scalar_v = is_scalar<_T>::value;
template<typename _T>
inline constexpr bool is_compound_v = is_compound<_T>::value;
template<typename _T>
inline constexpr bool is_member_pointer_v = is_member_pointer<_T>::value;

template<typename _T>
inline constexpr bool is_const_v = is_const<_T>::value;
template<typename _T>
inline constexpr bool is_volatile_v = is_volatile<_T>::value;
template<typename _T>
inline constexpr bool is_trivial_v = is_trivial<_T>::value;
template<typename _T>
inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<_T>::value;
template<typename _T>
inline constexpr bool is_standard_layout_v = is_standard_layout<_T>::value;
template<typename _T>
inline constexpr bool is_empty_v = is_empty<_T>::value;
template<typename _T>
inline constexpr bool is_polymorphic_v = is_polymorphic<_T>::value;
template<typename _T>
inline constexpr bool is_abstract_v = is_abstract<_T>::value;
template<typename _T>
inline constexpr bool is_final_v = is_final<_T>::value;
template<typename _T>
inline constexpr bool is_aggregate_v = is_aggregate<_T>::value;
template<typename _T>
inline constexpr bool is_signed_v = is_signed<_T>::value;
template<typename _T>
inline constexpr bool is_unsigned_v = is_unsigned<_T>::value;
template<typename _T>
inline constexpr bool is_bounded_array_v = is_bounded_array<_T>::value;
template<typename _T>
inline constexpr bool is_unbounded_array_v = is_unbounded_array<_T>::value;
template<typename _T>
inline constexpr bool is_scoped_enum_v = is_scoped_enum<_T>::value;
template<typename _T, typename... _Args>
inline constexpr bool is_constructible_v = is_constructible<_T, _Args...>::value;
template<typename _T>
inline constexpr bool is_default_constructible_v = is_default_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_move_constructible_v = is_move_constructible<_T>::value;
template<typename _T, typename _U>
inline constexpr bool is_assignable_v = is_assignable<_T, _U>::value;
template<typename _T>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_T>::value;
template<typename _T>
inline constexpr bool is_move_assignable_v = is_move_assignable<_T>::value;
template<typename _T, typename _U>
inline constexpr bool is_swappable_with_v = is_swappable_with<_T, _U>::value;
template<typename _T>
inline constexpr bool is_swappable_v = is_swappable<_T>::value;
template<typename _T>
inline constexpr bool is_destructible_v = is_destructible<_T>::value;
template<typename _T, typename... _Args>
inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<_T, _Args...>::value;
template<typename _T>
inline constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_T>::value;
template<typename _T, typename _U>
inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<_T, _U>::value;
template<typename _T>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_T>::value;
template<typename _T>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_T>::value;
template<typename _T>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_T>::value;
template<typename _T, typename... _Args>
inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_T, _Args...>::value;
template<typename _T>
inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_T>::value;
template<typename _T>
inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_T>::value;
template<typename _T, typename _U>
inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_T, _U>::value;
template<typename _T>
inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_T>::value;
template<typename _T>
inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_T>::value;
template<typename _T, typename _U>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_T, _U>::value;
template<typename _T>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_T>::value;
template<typename _T>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_T>::value;
template<typename _T>
inline constexpr bool has_virtual_destructor_v = has_virtual_destructor<_T>::value;
template<typename _T>
inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<_T>::value;

template<typename _T>
inline constexpr size_t alignment_of_v = alignment_of<_T>::value;
template<typename _T>
inline constexpr size_t rank_v = rank<_T>::value;
template<typename _T, unsigned _I = 0>
inline constexpr size_t extent_v = extent<_T, _I>::value;

template<typename _T, typename _U>
inline constexpr bool is_same_v = is_same<_T, _U>::value;
template<typename _Base, typename _Derived>
inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template<typename _From, typename _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<typename _From, typename _To>
inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_From, _To>::value;
template<typename _T, typename _U>
inline constexpr bool is_layout_compatible_v = is_layout_compatible<_T, _U>::value;
template<typename _Base, typename _Derived>
inline constexpr bool is_pointer_interconvertible_base_of_v =
    is_pointer_interconvertible_base_of<_Base, _Derived>::value;
template<typename _Fn, typename... _ArgTypes>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _ArgTypes...>::value;
template<typename _R, typename _Fn, typename... _ArgTypes>
inline constexpr bool is_invocable_r_v = is_invocable_r<_R, _Fn, _ArgTypes...>::value;
template<typename _Fn, typename... _ArgTypes>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _ArgTypes...>::value;
template<typename _R, typename _Fn, typename... _ArgTypes>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_R, _Fn, _ArgTypes...>::value;

template<class... _B>
inline constexpr bool conjunction_v = conjunction<_B...>::value;
template<class... _B>
inline constexpr bool disjunction_v = disjunction<_B...>::value;
template<typename _B>
inline constexpr bool negation_v = negation<_B>::value;

template<typename _S, typename _M>
constexpr bool is_pointer_interconvertible_with_class(_M _S::*__m) noexcept;
template<typename _S1, typename _S2, typename _M1, typename _M2>
constexpr bool is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept;

constexpr bool is_constant_evaluated() noexcept;
}

// vim: ft=cpp
