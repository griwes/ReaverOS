/*
 * Copyright © 2021 Michał 'Griwes' Dominiak
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <type_traits>

namespace std
{
template<typename _T>
concept __primary_template = is_same_v<_T, typename _T::__primary_template>;

template<typename _T, typename _U>
concept __same_as_impl = is_same_v<_T, _U>;

template<typename _T, typename _U>
concept same_as = __same_as_impl<_T, _U> && __same_as_impl<_U, _T>;

// template<class Derived, class Base>
// concept derived_from = see below;

// template<class From, class To>
// concept convertible_to = see below;

// template<class T, class U>
// concept common_reference_with = see below;

// template<class T, class U>
// concept common_with = see below;

template<typename _T>
concept integral = is_integral_v<_T>;
template<typename _T>
concept signed_integral = integral<_T> && is_signed_v<_T>;
template<typename _T>
concept unsigned_integral = integral<_T> && !signed_integral<_T>;
template<typename _T>
concept floating_point = is_floating_point_v<_T>;

// template<class LHS, class RHS>
// concept assignable_from = see below;

// namespace ranges
//{
// inline namespace unspecified
//{
// inline constexpr unspecified swap = unspecified;
//}
//}
// template<class T>
// concept swappable = see below;
// template<class T, class U>
// concept swappable_with = see below;

// template<class T>
// concept destructible = see below;

// template<class T, class... Args>
// concept constructible_from = see below;

// template<class T>
// concept default_initializable = see below;

// template<class T>
// concept move_constructible = see below;

// template<class T>
// concept copy_constructible = see below;

// template<class T>
// concept equality_comparable = see below;
// template<class T, class U>
// concept equality_comparable_with = see below;

// template<class T>
// concept totally_ordered = see below;
// template<class T, class U>
// concept totally_ordered_with = see below;

// template<class T>
// concept movable = see below;
// template<class T>
// concept copyable = see below;
// template<class T>
// concept semiregular = see below;
// template<class T>
// concept regular = see below;

// template<class F, class... Args>
// concept invocable = see below;

// template<class F, class... Args>
// concept regular_invocable = see below;

// template<class F, class... Args>
// concept predicate = see below;

// template<class R, class T, class U>
// concept relation = see below;

// template<class R, class T, class U>
// concept equivalence_relation = see below;

// template<class R, class T, class U>
// concept strict_weak_order = see below;
}

// vim: ft=cpp
